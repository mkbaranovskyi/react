# React Advanced 

- [React Advanced](#react-advanced)
	- [Error Boundaries](#error-boundaries)
		- [Basics](#basics)
			- [Full Example](#full-example)
		- [Details](#details)
			- [Where to put error boundaries](#where-to-put-error-boundaries)
			- [Development vs Production](#development-vs-production)
			- [Why not just `try..catch`?](#why-not-just-trycatch)
			- [Event handlers](#event-handlers)
	- [Fragments](#fragments)

***

## Error Boundaries

### Basics

https://reactjs.org/docs/error-boundaries.html

Error Boundaries are React components that catch JS errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed.

They work like `catch` block for components.

They do **not** catch errors for:

- Event handlers
- Async code
- Server-side rendering
- Errors in the error boundary itself

**Only class components** can be error boundaries. Most of the time youâ€™ll want to declare an error boundary component once and use it throughout your application.

To become an **error boundary**, class should define any (or both) of these methods:

- `static getDerivedStateFromError (error)` - should return updated State (which will trigger re-render) - the best for serving a fallback UI
- `componentDidCatch (error, errInfo)` - log error info here; you can update State (to render a fallback UI) here as well

```js
class ErrorBoundary extends React.Component {
	constructor(props) {
		super(props)
		this.state = { hasError: false }
	}

	static getDerivedStateFromError(error) {
		// Update state so the next render will show the fallback UI.
		return { hasError: true }
	}

	componentDidCatch(error, errorInfo) {
		// You can also log the error to an error reporting service
		logErrorToMyService(error, errorInfo)
	}

	render() {
		if (this.state.hasError) {
			// You can render any custom fallback UI
			return <h1>Something went wrong.</h1>
		}

		return this.props.children
	}
}
```

Then use it as a wrapper:

```html
<ErrorBoundary>
  <MyWidget />
</ErrorBoundary>
```

***

#### Full Example

```js
import React, { useState } from 'react'
import ReactDOM from 'react-dom'

class ErrorBoundary extends React.Component {
	constructor(props) {
		super(props)
		this.state = { error: null, errorInfo: null }
	}

	componentDidCatch(error, errorInfo) {
		// Catch errors in any components below and re-render with error message
		this.setState({
			error: error,
			errorInfo: errorInfo
		})
		// You can also log error messages to an error reporting service here
	}

	render() {
		if (this.state.errorInfo) {
			// Error path
			return (
				<div>
					<h2>Something went wrong.</h2>
					<details style={{ whiteSpace: 'pre-wrap' }}>
						{this.state.error && this.state.error.toString()}
						<br />
						{this.state.errorInfo.componentStack}
					</details>
				</div>
			)
		}
		// Normally, just render children
		return this.props.children
	}
}

function BuggyCounter(props) {
	const [counter, setCounter] = useState(0)

	function handleClick() {
		setCounter(() => counter + 1)
	}

	if (counter === 3) {
		// Simulate a JS error
		throw new Error('I crashed!')
	}
	return <h1 onClick={handleClick}>{counter}</h1>
}

function App() {
	return (
		<div>
			<p>
				<b>
					This is an example of error boundaries in React 16.
					<br />
					<br />
					Click on the numbers to increase the counters.
					<br />
					The counter is programmed to throw when it reaches 3. This simulates a
					JavaScript error in a component.
				</b>
			</p>
			<hr />
			<ErrorBoundary>
				<p>
					These two counters are inside the same error boundary. If one crashes,
					the error boundary will replace both of them.
				</p>
				<BuggyCounter />
				<BuggyCounter />
			</ErrorBoundary>
			<hr />
			<p>
				These two counters are each inside of their own error boundary. So if
				one crashes, the other is not affected.
			</p>
			<ErrorBoundary>
				<BuggyCounter />
			</ErrorBoundary>
			<ErrorBoundary>
				<BuggyCounter />
			</ErrorBoundary>
		</div>
	)
}

ReactDOM.render(<App />, document.getElementById('root'))
```

***

### Details

#### Where to put error boundaries

Anywhere you want. It might be:

- Around the **top-level** components to display a "Something went wrong" message. 
- Around **low-level** components to protect them from crashing the rest of the app. 

The best practice is to wrap all essential components in their separate error boundaries, plus wrap the top-level component in the last hope boundary. 

Uncaught errors will crash the app. 

***

#### Development vs Production

You might not see how Error Boundaries work in **development** because of the extra error messages - but they do work in **production**.

To switch to **production**, follow the instructions of `create-react-app`:

![](img/2021-02-15-14-02-12.png)

![](img/2021-02-15-14-02-44.png)

```bash
npm run build
# sudo npm i -g serve 
serve -s build
```

***

#### Why not just `try..catch`?

`try..catch` only works for **imperative** *("how")* code while React components are **declarative** *("what")*.

It means, you **cannot** do this, it **won't** work: 

```js
function App() {
	try {
		return (
			<BuggyCounter />
		)
	} catch (err) {
		console.log(err)
	}
}
```

Instead, you'll have to insert `try..catch` in **every** method of every component - not an elegant solution. 

*** 

#### Event handlers

Event handlers don't happen during rendering. If they throw, React still knows what to display on the screen.

Use regular `try..catch` if you need to catch an error inside event handler:

```js
handleClick() {
	try {
		// Do something that could throw
	} catch (error) {
		this.setState({ error });
	}
}
```

***


## Fragments

https://reactjs.org/docs/fragments.html

A common pattern in React is for a component to return **multiple elements**. 

Fragments **group a list of children** without adding extra nodes to the DOM.

Imagine you want to build a table:

```js
class Table extends React.Component {
  render() {
    return (
      <table>
        <tr>
          <Column />
        </tr>
      </table>
    )
  }
}
```

You `Column` component can't return multiple `<td>`s because React components can only return 

```js
render() {
  return (
    <React.Fragment>
      <ChildA />
      <ChildB />
      <ChildC />
    </React.Fragment>
  )
}
```

***


