# React Advanced 

- [React Advanced](#react-advanced)
	- [Error Boundaries](#error-boundaries)
		- [Basics](#basics)
			- [Full Example](#full-example)
		- [Details](#details)
			- [Where to put error boundaries](#where-to-put-error-boundaries)
			- [Development vs Production](#development-vs-production)
			- [Why not just `try..catch`?](#why-not-just-trycatch)
			- [Event handlers](#event-handlers)
	- [Fragments](#fragments)
		- [Basics](#basics-1)
			- [Full Example](#full-example-1)
		- [Details](#details-1)
			- [Why don't just always return arrays of elements?](#why-dont-just-always-return-arrays-of-elements)
	- [](#)

***

## Error Boundaries

https://reactjs.org/docs/error-boundaries.html

### Basics

Error Boundaries are React components that catch JS errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed.

They work like `catch` block for components.

They do **not** catch errors for:

- Event handlers
- Async code
- Server-side rendering
- Errors in the error boundary itself

**Only class components** can be error boundaries. Most of the time youâ€™ll want to declare an error boundary component once and use it throughout your application.

To become an **error boundary**, class should define any (or both) of these methods:

- `static getDerivedStateFromError (error)` - should return updated State (which will trigger re-render) - the best for serving a fallback UI
- `componentDidCatch (error, errInfo)` - log error info here; you can update State (to render a fallback UI) here as well

```js
class ErrorBoundary extends React.Component {
	constructor(props) {
		super(props)
		this.state = { hasError: false }
	}

	static getDerivedStateFromError(error) {
		// Update state so the next render will show the fallback UI.
		return { hasError: true }
	}

	componentDidCatch(error, errorInfo) {
		// You can also log the error to an error reporting service
		logErrorToMyService(error, errorInfo)
	}

	render() {
		if (this.state.hasError) {
			// You can render any custom fallback UI
			return <h1>Something went wrong.</h1>
		}

		return this.props.children
	}
}
```

Then use it as a wrapper:

```html
<ErrorBoundary>
  <MyWidget />
</ErrorBoundary>
```

***

#### Full Example

```js
import React, { useState } from 'react'
import ReactDOM from 'react-dom'

class ErrorBoundary extends React.Component {
	constructor(props) {
		super(props)
		this.state = { error: null, errorInfo: null }
	}

	componentDidCatch(error, errorInfo) {
		// Catch errors in any components below and re-render with error message
		this.setState({
			error: error,
			errorInfo: errorInfo
		})
		// You can also log error messages to an error reporting service here
	}

	render() {
		if (this.state.errorInfo) {
			// Error path
			return (
				<div>
					<h2>Something went wrong.</h2>
					<details style={{ whiteSpace: 'pre-wrap' }}>
						{this.state.error && this.state.error.toString()}
						<br />
						{this.state.errorInfo.componentStack}
					</details>
				</div>
			)
		}
		// Normally, just render children
		return this.props.children
	}
}

function BuggyCounter(props) {
	const [counter, setCounter] = useState(0)

	function handleClick() {
		setCounter(() => counter + 1)
	}

	if (counter === 3) {
		// Simulate a JS error
		throw new Error('I crashed!')
	}
	return <h1 onClick={handleClick}>{counter}</h1>
}

function App() {
	return (
		<div>
			<p>
				<b>
					This is an example of error boundaries in React 16.
					<br />
					<br />
					Click on the numbers to increase the counters.
					<br />
					The counter is programmed to throw when it reaches 3. This simulates a
					JavaScript error in a component.
				</b>
			</p>
			<hr />
			<ErrorBoundary>
				<p>
					These two counters are inside the same error boundary. If one crashes,
					the error boundary will replace both of them.
				</p>
				<BuggyCounter />
				<BuggyCounter />
			</ErrorBoundary>
			<hr />
			<p>
				These two counters are each inside of their own error boundary. So if
				one crashes, the other is not affected.
			</p>
			<ErrorBoundary>
				<BuggyCounter />
			</ErrorBoundary>
			<ErrorBoundary>
				<BuggyCounter />
			</ErrorBoundary>
		</div>
	)
}

ReactDOM.render(<App />, document.getElementById('root'))
```

***

### Details

#### Where to put error boundaries

Anywhere you want. It might be:

- Around the **top-level** components to display a "Something went wrong" message. 
- Around **low-level** components to protect them from crashing the rest of the app. 

The best practice is to wrap all essential components in their separate error boundaries, plus wrap the top-level component in the last hope boundary. 

Uncaught errors will crash the app. 

***

#### Development vs Production

You might not see how Error Boundaries work in **development** because of the extra error messages - but they do work in **production**.

To switch to **production**, follow the instructions of `create-react-app`:

![](img/2021-02-15-14-02-12.png)

![](img/2021-02-15-14-02-44.png)

```bash
npm run build
# sudo npm i -g serve 
serve -s build
```

***

#### Why not just `try..catch`?

`try..catch` only works for **imperative** *("how")* code while React components are **declarative** *("what")*.

It means, you **cannot** do this, it **won't** work: 

```js
function App() {
	try {
		return (
			<BuggyCounter />
		)
	} catch (err) {
		console.log(err)
	}
}
```

Instead, you'll have to insert `try..catch` in **every** method of every component - not an elegant solution. 

*** 

#### Event handlers

Event handlers don't happen during rendering. If they throw, React still knows what to display on the screen.

Use regular `try..catch` if you need to catch an error inside event handler:

```js
handleClick() {
	try {
		// Do something that could throw
	} catch (error) {
		this.setState({ error })
	}
}
```

***


## Fragments

https://reactjs.org/docs/fragments.html

### Basics

A common pattern in React is for a component to return **multiple elements**. 

Fragments **group a list of children** without adding extra nodes to the DOM.

E.g. this can be useful to return a list of `<li>` or `<td>`:

```js
// Classic syntax
<React.Fragment>
	<li></li>
	<li></li>
</React.Fragment>

// New simplified syntax
<>
	<li></li>
	<li></li>
</>
```

Though, in most cases you can just return array of elements.

***

#### Full Example

```js
import React from 'react'
import ReactDOM from 'react-dom'
import { nanoid } from 'nanoid'

function Table() {
	return (
		<table>
			<tbody>
				<tr>
					<Column />
				</tr>
				<tr>
					<Column />
				</tr>
			</tbody>
		</table>
	)
}

function Column() {
	/* Any of the 3 below will produce the same result */

	/* 1) Return an array of elements */

	// return [
	// 	<td key={nanoid()}>1</td>,
	// 	<td key={nanoid()}>2</td>,
	// 	<td key={nanoid()}>3</td>
	// ]

	/* 2) Return Classic Fragments */

	// return (
	// 	<React.Fragment>
	// 		<td key={nanoid()}>1</td>
	// 		<td key={nanoid()}>2</td>
	//		<td key={nanoid()}>3</td>
	// 	</React.Fragment>
	// )

	/* 3) Return Simplified Syntax Fragments */
	
	return (
		<>
			<td key={nanoid()}>1</td>
			<td key={nanoid()}>2</td>
			<td key={nanoid()}>3</td>
		</>
	)
}

function App() {
	return (
		<div>
			<Table />
		</div>
	)
}

ReactDOM.render(<App />, document.getElementById('root'))
```

***

### Details

#### Why don't just always return arrays of elements?

Because there can be cases when we can't. 

Classic syntax `React.Friagment` can have a `key` prop. This allows dynamically rendering lists of elements that require `key` but shouldn't be wrapped in extra elements:

```js
import React from 'react'
import ReactDOM from 'react-dom'
import { nanoid } from 'nanoid'

function Glossary(props) {
	return (
		<dl>
			{props.items.map((item) => (
				// Without `key`, React will fire a warning
				<React.Fragment key={item.id}>
					<dt>{item.term}</dt>
					<dd>{item.description}</dd>
				</React.Fragment>
			))}
		</dl>
	)
}

const glossary = [
	{
		id: nanoid(),
		term: 'WHO',
		description:
			'The World Health Organization is a specialized agency of the United Nations responsible for international public health.'
	},
	{
		id: nanoid(),
		term: 'ISS',
		description:
			'The International Space Station is a modular space station in low Earth orbit.'
	}
]

function App() {
	return (
		<div>
			<Glossary items={glossary} />
		</div>
	)
}

ReactDOM.render(<App />, document.getElementById('root'))
```

Here we cannot replace Fragment with array, as usual. We won't have an item to insert `key` into - so we'll get a warning:

```js
// BAD
function Glossary(props) {
	return (
		<dl>
			{props.items.map((item) =>
				[
					<dt>{item.term}</dt>, 
					<dd>{item.description}</dd>
				]
			)}
		</dl>
	)
}
```

***


## 